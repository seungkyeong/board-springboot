# Board Project
일상생활을 공유하는 자유로운 게시판입니다.


## 📚 목차
- [프로젝트 소개](#1-프로젝트-소개)
- [프로젝트 기능](#2-프로젝트-기능)
- [사용 기술](#3-사용-기술)
  - [백엔드](#3-1-백엔드)
  - [프론트엔드](#3-2-프론트엔드)
- [ERD](#4-db-설계)
- [API 명세](#api-명세)
- [실행 화면](#5-실행-화면)
- [느낀점](#5-느낀점)

## 📖 들어가며
### 1. 프로젝트 소개
<br/>

### 2. 프로젝트 기능
<br/>

### 3. 사용 기술
#### 3-1. 백엔드 
- 주요 프레임워크/라이브러리
  - Java 21
  - Spring Boot 3.4.0
  - Spring Data JPA
  - QueryDSL 5.0.0
  - Spring Security
  - JWT (java-jwt)
  - Lombok
  - AWS SDK
- Build Tool
  - gradle 8.11.1
- Database
  - Mysql
  - Redis
#### 3-2. 프론트엔드  
- Vue 3.2.13
- Pinia 4.0.3
- Element Plus 2.8.8
- jsonwebtoken 9.0.2 / jwt-decode 4.0.0  
<br/>

### 4. DB 설계
<br/>

### 5. 실행 화면
<details>
<summary>게시글 관련 화면</summary>
![전체게시글목록](https://github.com/user-attachments/assets/ca0ddd94-ec59-4d5d-bfe4-9ea74e18d2cc)
</details>

<br/>

## 💡 마치며
### 5. 느낀점
Spring Boot와 Vue를 사용해 웹 애플리케이션을 개발을 통해, JPA 기반의 데이터 처리 방식에 대해 고민할 수 있었습니다.

특히 “어디까지 DTO로 분리할 것인가”에 대한 고민이 많았습니다. Mybatis를 사용할 때는 SQL을 중심으로 데이터를 처리했기 때문에 DTO는 요청과 응답에서만 사용하는 구조였고, 역할의 경계도 명확했습니다. 반면, JPA는 Entity를 중심으로 동작하다 보니, 어떤 데이터를 Entity로 처리하고 어떤 시점에 DTO로 변환할지에 대한 기준을 명확히 세워야 했습니다. 간단한 로직에서는 Entity로 데이터를 조회한 뒤 DTO로 변환하여 반환했고, 특정 필드만 필요하거나 계산이 포함된 경우에는 QueryDSL의 Projections 기능으로 DTO를 직접 조회하였습니다. 이와 같이 요청과 응답에는 DTO를 사용하고, 내부 로직에서는 Entity를 활용하는 식으로 책임을 분리하며, 코드의 재사용성과 유지보수성을 높이고자 노력했습니다.

또한, 체이닝 방식으로 동적 쿼리를 구성해야 하다 보니 쿼리 재사용성과 중복을 어떻게 줄일지에 대한 고민이 많았습니다. 페이징 처리를 위해 count 쿼리와 실제 데이터 조회 쿼리를 나누는 과정에서 조건을 재활용하고자 QueryDSL의 clone()을 사용했지만, clone()이 내부적으로 join 조건을 복사하지 않아 예상과 달리 조인이 적용되지 않은 쿼리가 실행되었습니다. 이러한 문제를 해결하기 위해 공통 조건을 Base 쿼리 메서드로  분리하고, 각 쿼리에서는 필요한 select나 페이징 조건만 추가하여 중복을 줄이고 유지보수성을 높였습니다.

이번 프로젝트를 통해 ORM의 특성과 동작 방식을 이해할 수 있게 되었고, 재사용성과 성능 최적화를 고려하며 구조를 설계하는 경험을 쌓을 수 있는 좋은 경험이었습니다.
